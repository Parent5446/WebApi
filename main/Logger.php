<?php

if(!defined("API")) { return false; }

/**
 * This program was created to make a set of classes to be used for easy
 * website creation. Usage: simply extend the DB_Object class to make models
 * and the OUT_Request class to make controllers. HTML is stored in templates
 * with special tags. See the OUT_Template class for more details.
 * Made by Tyler Romeo <tylerromeo@gmail.com>
 *
 * Copyright (C) 2009 Tyler Romeo
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Logs important information generated by the script. Intended mainly
 * for logging database queries executed by other objects in this namespace.
 *
 * @package API
 * @author Tyler Romeo <tylerromeo@gmail.com>
 * @license http://opensource.org/licenses/gpl-3.0.html GNU General Public License 3.0
 * @copyright Copyright (c) 2009, Tyler Romeo (Some Rights Reserved)
 */
class MAIN_Logger
{

	/**
	 * Signal for extremely dangerous errors, usually
	 * resulting in termination of the script.
	 */
	const ERROR    = 256;

	/**
	 * Signal for critical errors, creating unwanted results, though
	 * not necessarily requiring the script to be terminated.
	 */
	const WARNING  = 512;

	/**
	 * Signal for standard errors that may have an effect on the outcome
	 * of the script in certain situations.
	 */
	const NOTICE   = 1024;

	/**
	 * Signal for important logging messages that are not errors, but denote
	 * important points in the script's execution.
	 */
	const INFO     = -1;

	/**
	 * Signal for possibly important logging messages that will only be needed
	 * as a source for developers to debug if there is a problem.
	 */
	const DEBUG    = -2;

	/**
	 * Signal for any expected errors or messages caused by the user, such as
	 * keyboard interrupts, etc.
	 */
	const USER     = -3;

	/**
	 * Stores the log itself, with a line for each array key.
	 * @private
	 */
	private $log = array();

	/**
	 * Creates a logging message from the given parameters and
	 * adds it to the log.
	 *
	 * @param int    $level    Level of the message (see the class's constants)
	 * @param string $callback Some identifier of what function caused the message to be logged
	 * @param string $message  The actual message to be logged
	 *
	 * @return bool Returns true on success, false on failure
	 */
	public function log($level, $callback, $message) {
		// First get a string with the level.
		switch($level) {
			case self::ERROR:
				$level = 'ERROR';
				break;
			case self::WARNING:
				$level = 'WARNING';
				break;
			case self::NOTICE:
				$level = 'NOTICE';
				break;
			case self::INFO:
				$level = 'INFO';
				break;
			case self::DEBUG:
				$level = 'DEBUG';
				break;
			case self::USER:
				$level = 'USER ERROR';
				break;
			default:
				return false;
		}

		// Retrieve any other variables necessary.
		$time = gmdate('c');
		$pid  = getmypid();

		// Create log line and append.
		$this->log[] = "$time ($pid) : $level [$callback] - $message";
		return true;
	}

	/**
	 * Takes the current internal log and exports it to a file before
	 * emptying it.
	 *
	 * @param string $filename Name of the file to export the log to
	 *
	 * @return int|bool Returns the number of bytes written, or false on error
	 */
	public function export($filename) {
		// Check the filename and return if already exists AND
		// is not a normal file.
		$filename = realpath($filename);
		if(file_exists($filename) && !is_file($filename)) {
			return new MAIN_Error(MAIN_Error::ERROR, 'MAIN_Logger::export', 'Log file is not a valid file.', $this);
		} $file = fopen($filename, 'a');

		// Check if the file failed to open,
		// then check if it is writable.
		if($file === false) {
			return new MAIN_Error(MAIN_Error::ERROR, 'MAIN_Logger::export', 'Log file failed to open.', $this);
		} elseif(!is_writable($filename)) {
			fclose($file);
			return new MAIN_Error(MAIN_Error::ERROR, 'MAIN_Logger::export', 'Log file is not writeable.', $this);
		}

		// Append the log to the file and close.
		$lines  = implode("\n", $this->log);
		$retval = fwrite($file, $lines);
		fclose($file);

		// Blank the internal log on success.
		if($retval == strlen($lines)) {
			$this->log = array();
			return $retval;
		} else {
			return new MAIN_Error(MAIN_Error::ERROR, 'MAIN_Logger::export', 'Writing to log file failed.', $this);
		}
	}
}

